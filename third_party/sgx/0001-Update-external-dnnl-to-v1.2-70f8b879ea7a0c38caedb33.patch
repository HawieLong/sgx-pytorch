From 66bc85e3d1aa903429a2a75b155d7f85b2aa74cb Mon Sep 17 00:00:00 2001
From: Yang Huang <yang.huang@intel.com>
Date: Thu, 13 May 2021 10:27:15 +0800
Subject: [PATCH 1/2] Update external dnnl to v1.2-70f8b879ea7a0c38caedb3320b

Signed-off-by: Yang Huang <yang.huang@intel.com>
---
 ...ebug-v1.2-70f8b879ea7a0c38caedb3320b.patch | 1022 +++++++++++++++++
 external/dnnl/Makefile                        |   16 +-
 external/dnnl/sgx_dnnl.patch                  |  615 ----------
 3 files changed, 1030 insertions(+), 623 deletions(-)
 create mode 100644 external/dnnl/0001-Enable-SGX-for-debug-v1.2-70f8b879ea7a0c38caedb3320b.patch
 delete mode 100644 external/dnnl/sgx_dnnl.patch

diff --git a/external/dnnl/0001-Enable-SGX-for-debug-v1.2-70f8b879ea7a0c38caedb3320b.patch b/external/dnnl/0001-Enable-SGX-for-debug-v1.2-70f8b879ea7a0c38caedb3320b.patch
new file mode 100644
index 00000000..727364f6
--- /dev/null
+++ b/external/dnnl/0001-Enable-SGX-for-debug-v1.2-70f8b879ea7a0c38caedb3320b.patch
@@ -0,0 +1,1022 @@
+From 92528f1b6e7659ae6e6e3d1336b7afc30cf4bd0e Mon Sep 17 00:00:00 2001
+From: Huang Yang <yang.huang@intel.com>
+Date: Wed, 27 Jan 2021 13:35:46 +0800
+Subject: [PATCH] Enable SGX for debug v1.2
+ 70f8b879ea7a0c38caedb3320b7c85e8497ff50d
+
+Signed-off-by: Huang Yang <yang.huang@intel.com>
+---
+ cmake/options.cmake                           |  13 +-
+ cmake/platform.cmake                          |   9 +-
+ src/CMakeLists.txt                            |   6 +-
+ src/common/engine.hpp                         |   2 +
+ src/common/primitive.cpp                      |   2 +
+ src/common/scratchpad.cpp                     |   2 +
+ src/common/utils.cpp                          |  20 +
+ src/common/utils.hpp                          |   2 +
+ src/common/verbose.cpp                        |   8 +
+ src/cpu/jit_uni_reorder_utils.cpp             |   2 +
+ src/cpu/jit_utils/jit_utils.cpp               |   8 +
+ src/cpu/jit_utils/jitprofiling/jitprofiling.c |   5 +
+ src/cpu/jit_utils/linux_perf/linux_perf.cpp   | 357 ------------------
+ src/cpu/xbyak/xbyak.h                         |  53 +++
+ src/cpu/xbyak/xbyak_util.h                    |  26 ++
+ 15 files changed, 152 insertions(+), 363 deletions(-)
+ delete mode 100644 src/cpu/jit_utils/linux_perf/linux_perf.cpp
+
+diff --git a/cmake/options.cmake b/cmake/options.cmake
+index e2539b322..0283bd13c 100644
+--- a/cmake/options.cmake
++++ b/cmake/options.cmake
+@@ -50,13 +50,18 @@ option(DNNL_ENABLE_MAX_CPU_ISA
+ # Building properties and scope
+ # =============================
+ 
+-set(DNNL_LIBRARY_TYPE "SHARED" CACHE STRING
++set(DNNL_LIBRARY_TYPE "STATIC" CACHE STRING
+     "specifies whether DNNL library should be SHARED or STATIC")
+-option(DNNL_BUILD_EXAMPLES "builds examples"  ON)
+-option(DNNL_BUILD_TESTS "builds tests" ON)
++option(DNNL_BUILD_EXAMPLES "builds examples"  OFF)
++option(DNNL_BUILD_TESTS "builds tests" OFF)
+ option(DNNL_BUILD_FOR_CI "specifies whether DNNL library should be built for CI" OFF)
+ option(DNNL_WERROR "treat warnings as errors" OFF)
+ 
++set( CMAKE_VERBOSE_MAKEFILE on )  #echo the build command info
++# ==enable DEBUG==
++set( CMAKE_BUILD_TYPE Debug )
++SET( CMAKE_CXX_FLAGS_DEBUG "$ENV{CXXFLAGS} -O0 -Wall -g -ggdb")
++
+ set(DNNL_INSTALL_MODE "DEFAULT" CACHE STRING
+     "specifies installation mode; supports DEFAULT or BUNDLE.
+ 
+@@ -102,7 +107,7 @@ option(DNNL_ENABLE_JIT_PROFILING
+     runtime with Intel VTune Amplifier (on by default). Without the
+     registrations, Intel VTune Amplifier would report data collected inside
+     the kernels as `outside any known module`."
+-    ON)
++    OFF)
+ 
+ # ===================
+ # Engine capabilities
+diff --git a/cmake/platform.cmake b/cmake/platform.cmake
+index fb5cda507..3343f68c1 100644
+--- a/cmake/platform.cmake
++++ b/cmake/platform.cmake
+@@ -30,6 +30,11 @@ add_definitions(-DDNNL_DLL -DDNNL_DLL_EXPORTS)
+ # C++ standard (see C99 standard 7.18.2 and 7.18.4)
+ add_definitions(-D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS)
+ 
++#SGX
++add_definitions(-DMKLDNN_SGX -DDISABLE_VERBOSE -DSGX_XBYAK)
++set(CMAKE_CXX_ENCLAVE_FLAGS)
++set(CMAKE_C_ENCLAVE_FLAGS)
++
+ set(CMAKE_CCXX_FLAGS)
+ set(CMAKE_CCXX_NOWARN_FLAGS)
+ set(CMAKE_CCXX_NOEXCEPT_FLAGS)
+@@ -87,7 +92,9 @@ elseif(UNIX OR MINGW)
+     append(CMAKE_CCXX_FLAGS "-Wall -Wno-unknown-pragmas")
+     append_if(DNNL_WERROR CMAKE_CCXX_FLAGS "-Werror")
+     append(CMAKE_CCXX_FLAGS "-fvisibility=internal")
+-    append(CMAKE_CXX_FLAGS "-fvisibility-inlines-hidden")
++    append(CMAKE_CXX_FLAGS "-fvisibility-inlines-hidden ${CMAKE_CXX_ENCLAVE_FLAGS}")
++    append(CMAKE_C_FLAGS "${CMAKE_C_ENCLAVE_FLAGS}")
++
+     append(CMAKE_CCXX_NOEXCEPT_FLAGS "-fno-exceptions")
+     # compiler specific settings
+     if(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
+index 491a457ff..b09a6db8f 100644
+--- a/src/CMakeLists.txt
++++ b/src/CMakeLists.txt
+@@ -22,6 +22,10 @@ file(GLOB_RECURSE HEADERS
+ include_directories(
+     ${CMAKE_CURRENT_SOURCE_DIR}
+     ${CMAKE_CURRENT_SOURCE_DIR}/common
++    ${CMAKE_CURRENT_SOURCE_DIR}/../../../../common/inc/internal
++    ${CMAKE_CURRENT_SOURCE_DIR}/../../../../common/inc/tlibc
++    ${CMAKE_CURRENT_SOURCE_DIR}/../../../../common/inc
++    ${CMAKE_CURRENT_SOURCE_DIR}/../../../../sdk/tlibcxx/include
+     )
+ 
+ # propagate SRC specific flags
+@@ -73,7 +77,7 @@ if(WIN32)
+ endif()
+ 
+ add_subdirectory(common)
+-add_subdirectory(compute)
++#add_subdirectory(compute)
+ add_subdirectory(cpu)
+ 
+ if(DNNL_GPU_RUNTIME STREQUAL "OCL")
+diff --git a/src/common/engine.hpp b/src/common/engine.hpp
+index 3c6138976..62d79976e 100644
+--- a/src/common/engine.hpp
++++ b/src/common/engine.hpp
+@@ -128,6 +128,7 @@ struct dnnl_engine : public dnnl::impl::c_compatible {
+ 
+         auto print_verbose = [](int level, bool is_cache_hit,
+                                      dnnl::impl::primitive_t *p, double time) {
++#ifndef MKLDNN_SGX
+             if (level >= 2) {
+ #ifdef DNNL_ENABLE_PRIMITIVE_CACHE
+                 const char *str = is_cache_hit
+@@ -139,6 +140,7 @@ struct dnnl_engine : public dnnl::impl::c_compatible {
+                 printf("%s,%s,%g\n", str, p->pd()->info(), time);
+                 fflush(0);
+             }
++#endif
+         };
+ 
+         double ms = dnnl::impl::get_msec();
+diff --git a/src/common/primitive.cpp b/src/common/primitive.cpp
+index b45ea3a2a..3de65b30b 100644
+--- a/src/common/primitive.cpp
++++ b/src/common/primitive.cpp
+@@ -74,8 +74,10 @@ status_t dnnl_primitive_execute(const primitive_t *primitive, stream_t *stream,
+         status = primitive->execute(ctx);
+         stream->wait();
+         ms = get_msec() - ms;
++	#ifndef MKLDNN_SGX
+         printf("dnnl_verbose,exec,%s,%g\n", primitive->pd()->info(), ms);
+         fflush(0);
++        #endif
+     } else {
+         status = primitive->execute(ctx);
+     }
+diff --git a/src/common/scratchpad.cpp b/src/common/scratchpad.cpp
+index 869af2af5..e7c8bb841 100644
+--- a/src/common/scratchpad.cpp
++++ b/src/common/scratchpad.cpp
+@@ -21,6 +21,8 @@
+ 
+ #include "scratchpad.hpp"
+ 
++extern "C" int __cxa_thread_atexit(void (*dtor)(void *), void *obj, void *dso_symbol) {} ;
++
+ namespace dnnl {
+ namespace impl {
+ 
+diff --git a/src/common/utils.cpp b/src/common/utils.cpp
+index 6d52ed10a..a7429e089 100644
+--- a/src/common/utils.cpp
++++ b/src/common/utils.cpp
+@@ -20,7 +20,9 @@
+ #endif
+ 
+ #ifdef __linux__
++#ifndef MKLDNN_SGX
+ #include <sys/stat.h>
++#endif
+ #include <sys/types.h>
+ #endif
+ 
+@@ -38,6 +40,7 @@ namespace dnnl {
+ namespace impl {
+ 
+ int getenv(const char *name, char *buffer, int buffer_size) {
++#ifndef MKLDNN_SGX
+     if (name == NULL || buffer_size < 0 || (buffer == NULL && buffer_size > 0))
+         return INT_MIN;
+ 
+@@ -69,17 +72,25 @@ int getenv(const char *name, char *buffer, int buffer_size) {
+ 
+     if (buffer != NULL) buffer[term_zero_idx] = '\0';
+     return result;
++#else
++    return 0;
++#endif
+ }
+ 
+ int getenv_int(const char *name, int default_value) {
++#ifndef MKLDNN_SGX
+     int value = default_value;
+     // # of digits in the longest 32-bit signed int + sign + terminating null
+     const int len = 12;
+     char value_str[len];
+     if (getenv(name, value_str, len) > 0) value = atoi(value_str);
+     return value;
++#else
++    return 0;
++#endif
+ }
+ 
++#ifndef MKLDNN_SGX
+ FILE *fopen(const char *filename, const char *mode) {
+ #ifdef _WIN32
+     FILE *fp = NULL;
+@@ -88,6 +99,7 @@ FILE *fopen(const char *filename, const char *mode) {
+     return ::fopen(filename, mode);
+ #endif
+ }
++#endif
+ 
+ void *malloc(size_t size, int alignment) {
+     void *ptr;
+@@ -96,7 +108,12 @@ void *malloc(size_t size, int alignment) {
+     ptr = _aligned_malloc(size, alignment);
+     int rc = ptr ? 0 : -1;
+ #else
++    #ifndef MKLDNN_SGX
+     int rc = ::posix_memalign(&ptr, alignment, size);
++    #else
++    ptr = ::memalign(alignment, size);
++    int rc = ((ptr)? 0 : -1);
++    #endif
+ #endif
+ 
+     return (rc == 0) ? ptr : 0;
+@@ -141,6 +158,7 @@ static setting_t<std::string> jit_profiling_jitdumpdir;
+ dnnl_status_t init_jit_profiling_jitdumpdir(
+         const char *jitdumpdir, bool overwrite) {
+ #ifdef __linux__
++    #ifndef MKLDNN_SGX
+     static std::mutex m;
+     std::lock_guard<std::mutex> g(m);
+ 
+@@ -159,6 +177,8 @@ dnnl_status_t init_jit_profiling_jitdumpdir(
+         jit_profiling_jitdumpdir.set(jitdumpdir);
+ 
+     return status::success;
++    #endif
++    return status::unimplemented;
+ #else
+     return status::unimplemented;
+ #endif
+diff --git a/src/common/utils.hpp b/src/common/utils.hpp
+index 8973c8215..a84043c26 100644
+--- a/src/common/utils.hpp
++++ b/src/common/utils.hpp
+@@ -490,10 +490,12 @@ inline void yield_thread() {}
+ int getenv(const char *name, char *buffer, int buffer_size);
+ // Reads an integer from the environment
+ int getenv_int(const char *name, int default_value = 0);
++#ifndef MKLDNN_SGX
+ bool get_jit_dump();
+ unsigned get_jit_profiling_flags();
+ std::string get_jit_profiling_jitdumpdir();
+ FILE *fopen(const char *filename, const char *mode);
++#endif
+ 
+ constexpr int msan_enabled = MSAN_ENABLED;
+ inline void msan_unpoison(void *ptr, size_t size) {
+diff --git a/src/common/verbose.cpp b/src/common/verbose.cpp
+index 0486f0773..30e715c89 100644
+--- a/src/common/verbose.cpp
++++ b/src/common/verbose.cpp
+@@ -15,9 +15,11 @@
+ *******************************************************************************/
+ 
+ #include <stdlib.h>
++#ifndef MKLDNN_SGX
+ #ifndef _WIN32
+ #include <sys/time.h>
+ #endif
++#endif
+ 
+ #include "dnnl.h"
+ #include "dnnl_debug.h"
+@@ -71,6 +73,7 @@ namespace impl {
+ 
+ static setting_t<int> verbose {0};
+ int get_verbose() {
++#ifndef MKLDNN_SGX
+ #if !defined(DISABLE_VERBOSE)
+     if (!verbose.initialized()) {
+         const int len = 2;
+@@ -93,6 +96,7 @@ int get_verbose() {
+ #endif
+         version_printed = true;
+     }
++#endif
+ #endif
+     return verbose.get();
+ }
+@@ -105,9 +109,13 @@ double get_msec() {
+     QueryPerformanceCounter(&now);
+     return 1e+3 * now.QuadPart / frequency.QuadPart;
+ #else
++    #ifndef MKLDNN_SGX
+     struct timeval time;
+     gettimeofday(&time, NULL);
+     return 1e+3 * time.tv_sec + 1e-3 * time.tv_usec;
++    #else
++    return 0.0;
++    #endif
+ #endif
+ }
+ 
+diff --git a/src/cpu/jit_uni_reorder_utils.cpp b/src/cpu/jit_uni_reorder_utils.cpp
+index 0ca8fcf16..55016a8a3 100644
+--- a/src/cpu/jit_uni_reorder_utils.cpp
++++ b/src/cpu/jit_uni_reorder_utils.cpp
+@@ -291,12 +291,14 @@ void prb_node_move(prb_t &p, int d0, int d1) {
+ }
+ 
+ void prb_dump(const prb_t &p) {
++#ifndef MKLDNN_SGX
+     printf("@@@ type:%s:%s ndims:%d ", dnnl_dt2str(p.itype),
+             dnnl_dt2str(p.otype), p.ndims);
+     for (int d = 0; d < p.ndims; ++d)
+         printf("[%zu:%td:%td:%td]", p.nodes[d].n, p.nodes[d].is, p.nodes[d].os,
+                 p.nodes[d].ss);
+     printf(" off:%zu:%zu\n", p.ioff, p.ooff);
++#endif
+ }
+ 
+ } // namespace tr
+diff --git a/src/cpu/jit_utils/jit_utils.cpp b/src/cpu/jit_utils/jit_utils.cpp
+index 8ada1d75b..75045ee2a 100644
+--- a/src/cpu/jit_utils/jit_utils.cpp
++++ b/src/cpu/jit_utils/jit_utils.cpp
+@@ -18,13 +18,21 @@
+ 
+ #include "utils.hpp"
+ 
++#ifndef MKLDNN_SGX
+ #ifndef DNNL_ENABLE_JIT_PROFILING
+ #define DNNL_ENABLE_JIT_PROFILING 1
+ #endif
++#else
++#undef DNNL_ENABLE_JIT_PROFILING
++#endif
+ 
++#ifndef MKLDNN_SGX
+ #ifndef DNNL_ENABLE_JIT_DUMP
+ #define DNNL_ENABLE_JIT_DUMP 1
+ #endif
++#else
++#undef DNNL_ENABLE_JIT_DUMP
++#endif
+ 
+ #if DNNL_ENABLE_JIT_PROFILING
+ #include "jitprofiling/jitprofiling.h"
+diff --git a/src/cpu/jit_utils/jitprofiling/jitprofiling.c b/src/cpu/jit_utils/jitprofiling/jitprofiling.c
+index fd99cb5f3..433d58370 100644
+--- a/src/cpu/jit_utils/jitprofiling/jitprofiling.c
++++ b/src/cpu/jit_utils/jitprofiling/jitprofiling.c
+@@ -35,6 +35,8 @@
+   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ </copyright> */
+ 
++#ifndef MKLDNN_SGX
++
+ #include "ittnotify_config.h"
+ 
+ #if ITT_PLATFORM==ITT_PLATFORM_WIN
+@@ -291,3 +293,6 @@ ITT_EXTERN_C unsigned int JITAPI iJIT_GetNewMethodID()
+ 
+     return methodID++;
+ }
++
++#endif  //#ifndef MKLDNN_SGX
++
+diff --git a/src/cpu/jit_utils/linux_perf/linux_perf.cpp b/src/cpu/jit_utils/linux_perf/linux_perf.cpp
+deleted file mode 100644
+index d1a6ebf20..000000000
+--- a/src/cpu/jit_utils/linux_perf/linux_perf.cpp
++++ /dev/null
+@@ -1,357 +0,0 @@
+-/*******************************************************************************
+-* Copyright 2019 Intel Corporation
+-*
+-* Licensed under the Apache License, Version 2.0 (the "License");
+-* you may not use this file except in compliance with the License.
+-* You may obtain a copy of the License at
+-*
+-*     http://www.apache.org/licenses/LICENSE-2.0
+-*
+-* Unless required by applicable law or agreed to in writing, software
+-* distributed under the License is distributed on an "AS IS" BASIS,
+-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+-* See the License for the specific language governing permissions and
+-* limitations under the License.
+-*******************************************************************************/
+-
+-// A quick-and-dirty implementation of
+-// ----------------------------------
+-// tools/perf/Documentation/jitdump-specification.txt
+-// tools/perf/Documentation/jit-interface.txt
+-
+-// WARNING: this implementation is inherently non-thread-safe. Any calls to
+-// linux_perf_record_code_load() MUST be protected by a mutex.
+-
+-#ifdef __linux__
+-
+-#include <sys/mman.h>
+-#include <sys/stat.h>
+-#include <sys/types.h>
+-
+-#include <elf.h>
+-#include <errno.h>
+-#include <fcntl.h>
+-#include <syscall.h>
+-#include <unistd.h>
+-
+-#include <climits>
+-#include <cstdint>
+-#include <cstdio>
+-#include <cstring>
+-#include <ctime>
+-
+-#include <string>
+-
+-#include "linux_perf.hpp"
+-#include "utils.hpp"
+-#include "verbose.hpp"
+-
+-namespace dnnl {
+-namespace impl {
+-namespace cpu {
+-namespace jit_utils {
+-
+-class linux_perf_jitdump_t {
+-public:
+-    linux_perf_jitdump_t()
+-        : marker_addr_ {nullptr}
+-        , marker_size_ {0}
+-        , fd_ {-1}
+-        , failed_ {false}
+-        , use_tsc_ {false} {
+-        // The initialization is lazy and nothing happens if no JIT-ed code
+-        // need to be recorded.
+-    }
+-
+-    ~linux_perf_jitdump_t() {
+-        write_code_close();
+-        finalize();
+-    }
+-
+-    void record_code_load(
+-            const void *code, size_t code_size, const char *code_name) {
+-        if (is_active()) write_code_load(code, code_size, code_name);
+-    }
+-
+-private:
+-    bool is_active() {
+-        if (fd_ >= 0) return true;
+-        if (failed_) return false;
+-        return initialize();
+-    }
+-
+-    bool initialize() {
+-        if (!open_file()) return fail();
+-        if (!create_marker()) return fail();
+-        if (!write_header()) return fail();
+-        return true;
+-    }
+-
+-    void finalize() {
+-        close_file();
+-        delete_marker();
+-    }
+-
+-    bool fail() {
+-        finalize();
+-        failed_ = true;
+-        return false;
+-    }
+-
+-    bool open_file() {
+-        auto path_len_ok = [&](const std::string &path) {
+-            if (path.length() >= PATH_MAX) {
+-                if (get_verbose())
+-                    printf("dnnl_verbose,jit_perf,error,"
+-                           "dump directory path '%s' is too long\n",
+-                            path.c_str());
+-                return false;
+-            }
+-            return true;
+-        };
+-
+-        auto complain = [](const std::string &path) {
+-            if (get_verbose())
+-                printf("dnnl_verbose,jit_perf,error,"
+-                       "cannot create dump directory '%s' (%m)\n",
+-                        path.c_str());
+-            return false;
+-        };
+-
+-        auto make_dir = [&](const std::string &path) {
+-            if (!path_len_ok(path)) return false;
+-            if (mkdir(path.c_str(), 0755) == -1 && errno != EEXIST)
+-                return complain(path);
+-            return true;
+-        };
+-
+-        auto make_temp_dir = [&](std::string &path) {
+-            if (!path_len_ok(path)) return false;
+-            if (mkdtemp(&path[0]) == nullptr) return complain(path);
+-            return true;
+-        };
+-
+-        std::string path(get_jit_profiling_jitdumpdir());
+-        path.reserve(PATH_MAX);
+-
+-        if (!make_dir(path)) return false;
+-
+-        path += "/.debug";
+-        if (!make_dir(path)) return false;
+-
+-        path += "/jit";
+-        if (!make_dir(path)) return false;
+-
+-        path += "/dnnl.XXXXXX";
+-        if (!make_temp_dir(path)) return false;
+-
+-        path += "/jit-" + std::to_string(getpid()) + ".dump";
+-        if (!path_len_ok(path)) return false;
+-
+-        fd_ = open(path.c_str(), O_CREAT | O_TRUNC | O_RDWR, 0666);
+-        if (fd_ == -1) {
+-            if (get_verbose())
+-                printf("dnnl_verbose,jit_perf,error,"
+-                       "cannot open jitdump file '%s' (%m)\n",
+-                        path.c_str());
+-            return false;
+-        }
+-
+-        return true;
+-    }
+-
+-    void close_file() {
+-        if (fd_ == -1) return;
+-        close(fd_);
+-        fd_ = -1;
+-    }
+-
+-    bool create_marker() {
+-        // Perf will record an mmap() call and then will find the file we
+-        // write the JIT-ed code to. PROT_EXEC ensures that the record is not
+-        // ignored.
+-        long page_size = sysconf(_SC_PAGESIZE);
+-        if (page_size == -1) return false;
+-        marker_size_ = (size_t)page_size;
+-        marker_addr_ = mmap(
+-                NULL, marker_size_, PROT_READ | PROT_EXEC, MAP_PRIVATE, fd_, 0);
+-        return marker_addr_ != MAP_FAILED;
+-    }
+-
+-    void delete_marker() {
+-        if (marker_addr_) munmap(marker_addr_, marker_size_);
+-    }
+-
+-    static uint64_t get_timestamp(bool use_tsc) {
+-        if (use_tsc) {
+-            uint32_t hi, lo;
+-            asm volatile("rdtsc" : "=a"(lo), "=d"(hi));
+-            return (((uint64_t)hi) << 32) | lo;
+-        } else {
+-            struct timespec ts;
+-            int rc = clock_gettime(CLOCK_MONOTONIC, &ts);
+-            if (rc) return 0;
+-            return (ts.tv_sec * 1000000000UL) + ts.tv_nsec;
+-        }
+-    }
+-
+-    static pid_t gettid() {
+-        // https://sourceware.org/bugzilla/show_bug.cgi?id=6399
+-        return (pid_t)syscall(__NR_gettid);
+-    }
+-
+-    bool write_or_fail(const void *buf, size_t size) {
+-        // Write data to the output file or do nothing if the object is in the
+-        // failed state. Enter failed state on errors.
+-        if (failed_) return false;
+-        ssize_t ret = write(fd_, buf, size);
+-        if (ret == -1) return fail();
+-        return true;
+-    }
+-
+-    bool write_header() {
+-        struct {
+-            uint32_t magic;
+-            uint32_t version;
+-            uint32_t total_size;
+-            uint32_t elf_mach;
+-            uint32_t pad1;
+-            uint32_t pid;
+-            uint64_t timestamp;
+-            uint64_t flags;
+-        } h;
+-        h.magic = 0x4A695444; // JITHEADER_MAGIC ('DTiJ')
+-        h.version = 1;
+-        h.total_size = sizeof(h);
+-        h.elf_mach = EM_X86_64;
+-        h.pad1 = 0;
+-        h.pid = getpid();
+-
+-        use_tsc_ = get_jit_profiling_flags()
+-                & DNNL_JIT_PROFILE_LINUX_JITDUMP_USE_TSC;
+-        h.timestamp = get_timestamp(use_tsc_);
+-        h.flags = use_tsc_ ? 1 : 0;
+-
+-        return write_or_fail(&h, sizeof(h));
+-    }
+-
+-    bool write_code_close() {
+-        struct {
+-            uint32_t id;
+-            uint32_t total_size;
+-            uint64_t timestamp;
+-        } c;
+-        c.id = 3; // JIT_CODE_CLOSE
+-        c.total_size = sizeof(c);
+-        c.timestamp = get_timestamp(use_tsc_);
+-        return write_or_fail(&c, sizeof(c));
+-    }
+-
+-    bool write_code_load(
+-            const void *code, size_t code_size, const char *code_name) {
+-        // XXX (rsdubtso): There is no limit on code_size or code_name. This
+-        // may lead to huge output files. Do we care?
+-        static uint64_t code_index = 0;
+-        struct {
+-            uint32_t id;
+-            uint32_t total_size;
+-            uint64_t timestamp;
+-            uint32_t pid;
+-            uint32_t tid;
+-            uint64_t vma;
+-            uint64_t code_addr;
+-            uint64_t code_size;
+-            uint64_t code_index;
+-        } c;
+-        c.id = 0; // JIT_CODE_LOAD
+-        c.total_size = sizeof(c) + strlen(code_name) + 1 + code_size;
+-        c.timestamp = get_timestamp(use_tsc_);
+-        c.pid = getpid();
+-        c.tid = gettid();
+-        c.vma = c.code_addr = (uint64_t)code;
+-        c.code_size = code_size;
+-        c.code_index = code_index++;
+-        write_or_fail(&c, sizeof(c));
+-        write_or_fail(code_name, strlen(code_name) + 1);
+-        return write_or_fail(code, code_size);
+-    }
+-
+-    void *marker_addr_;
+-    size_t marker_size_;
+-    int fd_;
+-    bool failed_;
+-    bool use_tsc_;
+-};
+-
+-void linux_perf_jitdump_record_code_load(
+-        const void *code, size_t code_size, const char *code_name) {
+-    static linux_perf_jitdump_t jitdump;
+-    jitdump.record_code_load(code, code_size, code_name);
+-}
+-
+-class linux_perf_jitmap_t {
+-public:
+-    linux_perf_jitmap_t() : fp_ {nullptr}, failed_ {false} {}
+-    ~linux_perf_jitmap_t() {}
+-    void record_symbol(
+-            const void *code, size_t code_size, const char *code_name) {
+-        if (is_initialized()) write_symbol_info(code, code_size, code_name);
+-    }
+-
+-private:
+-    bool is_initialized() {
+-        if (fp_) return true;
+-        if (failed_) return false;
+-        return initialize();
+-    }
+-
+-    bool open_map_file() {
+-        char fname[PATH_MAX];
+-        int ret = snprintf(fname, PATH_MAX, "/tmp/perf-%d.map", getpid());
+-        if (ret >= PATH_MAX) return fail();
+-
+-        fp_ = fopen(fname, "w+");
+-        if (!fp_) return fail();
+-        setvbuf(fp_, NULL, _IOLBF, 0); // disable line buffering
+-
+-        return true;
+-    }
+-
+-    void close_map_file() {
+-        if (fp_) fclose(fp_);
+-    }
+-
+-    bool initialize() { return open_map_file(); }
+-
+-    bool fail() {
+-        close_map_file();
+-        failed_ = true;
+-        return false;
+-    }
+-
+-    void write_symbol_info(
+-            const void *code, size_t code_size, const char *code_name) {
+-        if (failed_) return;
+-
+-        int ret = fprintf(fp_, "%llx %llx %s\n", (unsigned long long)code,
+-                (unsigned long long)code_size, code_name);
+-
+-        if (ret == EOF || ret < 0) fail();
+-    }
+-
+-    FILE *fp_;
+-    bool failed_;
+-};
+-
+-void linux_perf_perfmap_record_code_load(
+-        const void *code, size_t code_size, const char *code_name) {
+-    static linux_perf_jitmap_t jitmap;
+-    jitmap.record_symbol(code, code_size, code_name);
+-}
+-
+-} // namespace jit_utils
+-} // namespace cpu
+-} // namespace impl
+-} // namespace dnnl
+-
+-#endif
+diff --git a/src/cpu/xbyak/xbyak.h b/src/cpu/xbyak/xbyak.h
+index 04279e28d..8b63148ba 100644
+--- a/src/cpu/xbyak/xbyak.h
++++ b/src/cpu/xbyak/xbyak.h
+@@ -72,6 +72,10 @@
+ #include <iostream>
+ #endif
+ 
++#ifdef SGX_XBYAK
++#include "sgx_rsrv_mem_mngr.h"
++#endif
++
+ // #define XBYAK_DISABLE_AVX512
+ 
+ //#define XBYAK_USE_MMAP_ALLOCATOR
+@@ -125,7 +129,9 @@
+ 	#include <malloc.h>
+ #elif defined(__GNUC__)
+ 	#include <unistd.h>
++        #ifndef SGX_XBYAK
+ 	#include <sys/mman.h>
++        #endif
+ 	#include <stdlib.h>
+ #endif
+ #if defined(__APPLE__) && defined(MAP_JIT)
+@@ -320,9 +326,13 @@ inline void *AlignedMalloc(size_t size, size_t alignment)
+ #elif defined(_WIN32)
+ 	return _aligned_malloc(size, alignment);
+ #else
++	#ifndef SGX_XBYAK
+ 	void *p;
+ 	int ret = posix_memalign(&p, alignment, size);
+ 	return (ret == 0) ? p : 0;
++	#else
++	return NULL;
++	#endif
+ #endif
+ }
+ 
+@@ -408,6 +418,8 @@ public:
+ 	{
+ 		const size_t alignedSizeM1 = inner::ALIGN_PAGE_SIZE - 1;
+ 		size = (size + alignedSizeM1) & ~alignedSizeM1;
++#ifndef SGX_XBYAK
++
+ #if defined(XBYAK_USE_MAP_JIT)
+ 		int mode = MAP_PRIVATE | MAP_ANONYMOUS;
+ 		const int mojaveVersion = 18;
+@@ -424,13 +436,27 @@ public:
+ 		assert(p);
+ 		sizeList_[(uintptr_t)p] = size;
+ 		return (uint8*)p;
++#else
++		void *p = sgx_alloc_rsrv_mem(size);
++		if (p == NULL)
++			abort();
++		sizeList_[(uintptr_t)p] = size;
++		return (uint8*)p;
++#endif
+ 	}
+ 	void free(uint8 *p)
+ 	{
+ 		if (p == 0) return;
+ 		SizeList::iterator i = sizeList_.find((uintptr_t)p);
++#ifndef SGX_XBYAK
+ 		if (i == sizeList_.end()) throw Error(ERR_BAD_PARAMETER);
+ 		if (munmap((void*)i->first, i->second) < 0) throw Error(ERR_MUNMAP);
++#else
++		if (i == sizeList_.end())
++			abort();
++		if(sgx_free_rsrv_mem((void*)i->first, i->second) !=  0)
++			abort();
++#endif
+ 		sizeList_.erase(i);
+ 	}
+ };
+@@ -990,8 +1016,14 @@ public:
+ 	explicit CodeArray(size_t maxSize, void *userPtr = 0, Allocator *allocator = 0)
+ 		: type_(userPtr == AutoGrow ? AUTO_GROW : (userPtr == 0 || userPtr == DontSetProtectRWE) ? ALLOC_BUF : USER_BUF)
+ 		, alloc_(allocator ? allocator : (Allocator*)&defaultAllocator_)
++		#ifndef SGX_XBYAK
+ 		, maxSize_(maxSize)
+ 		, top_(type_ == USER_BUF ? reinterpret_cast<uint8*>(userPtr) : alloc_->alloc((std::max<size_t>)(maxSize, 1)))
++		#else
++		//Inside SGX, the allocated memory size must be page aligned.
++		, maxSize_((maxSize +  (inner::ALIGN_PAGE_SIZE - 1)) & ~(inner::ALIGN_PAGE_SIZE - 1))
++		, top_(type_ == USER_BUF ? reinterpret_cast<uint8*>(userPtr) : alloc_->alloc((std::max<size_t>)(((maxSize +  (inner::ALIGN_PAGE_SIZE - 1)) & ~(inner::ALIGN_PAGE_SIZE - 1)), 1)))
++		#endif
+ 		, size_(0)
+ 		, isCalledCalcJmpAddress_(false)
+ 	{
+@@ -1060,6 +1092,7 @@ public:
+ 	}
+ 	void dump() const
+ 	{
++		#ifndef SGX_XBYAK
+ 		const uint8 *p = getCode();
+ 		size_t bufSize = getSize();
+ 		size_t remain = bufSize;
+@@ -1079,6 +1112,7 @@ public:
+ 				break;
+ 			}
+ 		}
++		#endif
+ 	}
+ 	/*
+ 		@param offset [in] offset from top
+@@ -1109,6 +1143,7 @@ public:
+ 	*/
+ 	static inline bool protect(const void *addr, size_t size, int protectMode)
+ 	{
++#ifndef SGX_XBYAK
+ #if defined(_WIN32)
+ 		const DWORD c_rw = PAGE_READWRITE;
+ 		const DWORD c_rwe = PAGE_EXECUTE_READWRITE;
+@@ -1140,6 +1175,20 @@ public:
+ 		return mprotect(reinterpret_cast<void*>(roundAddr), size + (iaddr - roundAddr), mode) == 0;
+ #else
+ 		return true;
++#endif
++#else
++	const int c_rw = SGX_PROT_READ | SGX_PROT_WRITE;
++	const int c_rwe = SGX_PROT_READ | SGX_PROT_WRITE | SGX_PROT_EXEC;
++	const int c_re = SGX_PROT_READ | SGX_PROT_EXEC;
++	int mode;
++	switch (protectMode) {
++	case PROTECT_RW: mode = c_rw; break;
++	case PROTECT_RWE: mode = c_rwe; break;
++	case PROTECT_RE: mode = c_re; break;
++	default:
++		return false;
++	}
++	return sgx_tprotect_rsrv_mem(const_cast<void*>(addr), size, mode) == 0;
+ #endif
+ 	}
+ 	/**
+@@ -1373,9 +1422,11 @@ class LabelManager {
+ 	bool hasUndefinedLabel_inner(const T& list) const
+ 	{
+ #ifndef NDEBUG
++		#ifndef SGX_XBYAK
+ 		for (typename T::const_iterator i = list.begin(); i != list.end(); ++i) {
+ 			std::cerr << "undefined label:" << i->first << std::endl;
+ 		}
++		#endif
+ #endif
+ 		return !list.empty();
+ 	}
+@@ -2702,7 +2753,9 @@ public:
+ 	{
+ 		if (x == 1) return;
+ 		if (x < 1 || (x & (x - 1))) throw Error(ERR_BAD_ALIGN);
++		#ifndef SGX_XBYAK
+ 		if (isAutoGrow() && x > inner::ALIGN_PAGE_SIZE) fprintf(stderr, "warning:autoGrow mode does not support %d align\n", (int)x);
++		#endif
+ 		size_t remain = size_t(getCurr()) % x;
+ 		if (remain) {
+ 			nop(x - remain, useMultiByteNop);
+diff --git a/src/cpu/xbyak/xbyak_util.h b/src/cpu/xbyak/xbyak_util.h
+index a66b1eff6..2bc49c7e0 100644
+--- a/src/cpu/xbyak/xbyak_util.h
++++ b/src/cpu/xbyak/xbyak_util.h
+@@ -86,7 +86,11 @@
+     	#define __GNUC_PREREQ(major, minor) ((((__GNUC__) << 16) + (__GNUC_MINOR__)) >= (((major) << 16) + (minor)))
+ 	#endif
+ 	#if __GNUC_PREREQ(4, 3) && !defined(__APPLE__)
++		#ifndef SGX_XBYAK
+ 		#include <cpuid.h>
++		#else
++		#include <sgx_cpuid.h>
++		#endif
+ 	#else
+ 		#if defined(__APPLE__) && defined(XBYAK32) // avoid err : can't find a register in class `BREG' while reloading `asm'
+ 			#define __cpuid(eaxIn, a, b, c, d) __asm__ __volatile__("pushl %%ebx\ncpuid\nmovl %%ebp, %%esi\npopl %%ebx" : "=a"(a), "=S"(b), "=c"(c), "=d"(d) : "0"(eaxIn))
+@@ -110,8 +114,10 @@
+ 	#endif
+ #endif
+ #ifdef __linux__
++#ifndef SGX_XBYAK
+ 	#define XBYAK_USE_PERF
+ #endif
++#endif
+ 
+ namespace Xbyak { namespace util {
+ 
+@@ -290,11 +296,15 @@ public:
+ 	static inline void getCpuid(unsigned int eaxIn, unsigned int data[4])
+ 	{
+ #ifdef XBYAK_INTEL_CPU_SPECIFIC
++	#ifndef SGX_XBYAK
+ 	#ifdef _MSC_VER
+ 		__cpuid(reinterpret_cast<int*>(data), eaxIn);
+ 	#else
+ 		__cpuid(eaxIn, data[0], data[1], data[2], data[3]);
+ 	#endif
++	#else
++		sgx_cpuid((int*)data, eaxIn);
++	#endif
+ #else
+ 		(void)eaxIn;
+ 		(void)data;
+@@ -303,11 +313,15 @@ public:
+ 	static inline void getCpuidEx(unsigned int eaxIn, unsigned int ecxIn, unsigned int data[4])
+ 	{
+ #ifdef XBYAK_INTEL_CPU_SPECIFIC
++	#ifndef SGX_XBYAK
+ 	#ifdef _MSC_VER
+ 		__cpuidex(reinterpret_cast<int*>(data), eaxIn, ecxIn);
+ 	#else
+ 		__cpuid_count(eaxIn, ecxIn, data[0], data[1], data[2], data[3]);
+ 	#endif
++	#else
++		sgx_cpuidex((int*)data, eaxIn, ecxIn);
++	#endif
+ #else
+ 		(void)eaxIn;
+ 		(void)ecxIn;
+@@ -507,9 +521,11 @@ public:
+ 	}
+ 	void putFamily() const
+ 	{
++		#ifndef SGX_XBYAK
+ 		printf("family=%d, model=%X, stepping=%d, extFamily=%d, extModel=%X\n",
+ 			family, model, stepping, extFamily, extModel);
+ 		printf("display:family=%X, model=%X\n", displayFamily, displayModel);
++		#endif
+ 	}
+ 	bool has(Type type) const
+ 	{
+@@ -601,7 +617,9 @@ public:
+ 	Pack& append(const Xbyak::Reg64& t)
+ 	{
+ 		if (n_ == maxTblNum) {
++			#ifndef SGX_XBYAK
+ 			fprintf(stderr, "ERR Pack::can't append\n");
++			#endif
+ 			throw Error(ERR_BAD_PARAMETER);
+ 		}
+ 		tbl_[n_++] = &t;
+@@ -610,7 +628,9 @@ public:
+ 	void init(const Xbyak::Reg64 *tbl, size_t n)
+ 	{
+ 		if (n > maxTblNum) {
++			#ifndef SGX_XBYAK
+ 			fprintf(stderr, "ERR Pack::init bad n=%d\n", (int)n);
++			#endif
+ 			throw Error(ERR_BAD_PARAMETER);
+ 		}
+ 		n_ = n;
+@@ -621,7 +641,9 @@ public:
+ 	const Xbyak::Reg64& operator[](size_t n) const
+ 	{
+ 		if (n >= n_) {
++			#ifndef SGX_XBYAK
+ 			fprintf(stderr, "ERR Pack bad n=%d(%d)\n", (int)n, (int)n_);
++			#endif
+ 			throw Error(ERR_BAD_PARAMETER);
+ 		}
+ 		return *tbl_[n];
+@@ -634,7 +656,9 @@ public:
+ 	{
+ 		if (num == size_t(-1)) num = n_ - pos;
+ 		if (pos + num > n_) {
++			#ifndef SGX_XBYAK
+ 			fprintf(stderr, "ERR Pack::sub bad pos=%d, num=%d\n", (int)pos, (int)num);
++			#endif
+ 			throw Error(ERR_BAD_PARAMETER);
+ 		}
+ 		Pack pack;
+@@ -646,10 +670,12 @@ public:
+ 	}
+ 	void put() const
+ 	{
++		#ifndef SGX_XBYAK
+ 		for (size_t i = 0; i < n_; i++) {
+ 			printf("%s ", tbl_[i]->toString());
+ 		}
+ 		printf("\n");
++		#endif
+ 	}
+ };
+ 
+-- 
+2.25.1
+
diff --git a/external/dnnl/Makefile b/external/dnnl/Makefile
index feb1444d..900073af 100644
--- a/external/dnnl/Makefile
+++ b/external/dnnl/Makefile
@@ -76,15 +76,15 @@ $(SGX_DNNL_INCLUDE):
 
 .PHONY: dnnl_src
 dnnl_src:
-ifeq ($(shell git rev-parse --is-inside-work-tree), true)
-	@$(RM) -r $(DNNL_DIR)/*
-	git submodule update -f --init dnnl
-	cd $(DNNL_DIR) && git am ../sgx_dnnl.patch
-else
+#ifeq ($(shell git rev-parse --is-inside-work-tree), true)
+#	@$(RM) -r $(DNNL_DIR)/*
+#	git submodule update -f --init dnnl
+#	cd $(DNNL_DIR) && git am ../0001-Enable-SGX-for-debug-v1.2-70f8b879ea7a0c38caedb3320b.patch
+#else
 	@$(RM) -r $(DNNL_DIR)
-	git clone https://github.com/intel/mkl-dnn.git -b v1.1.1 --depth 1  $(DNNL_DIR)
-	cd $(DNNL_DIR) && git am ../sgx_dnnl.patch
-endif
+	git clone https://github.com/oneapi-src/oneDNN.git $(DNNL_DIR)
+	cd $(DNNL_DIR) && git reset --hard 70f8b879ea7a0c38caedb3320b7c85e8497ff50d && git am ../0001-Enable-SGX-for-debug-v1.2-70f8b879ea7a0c38caedb3320b.patch
+#endif
 
 $(LIBDNNL):$(CHECK_SOURCE)
 	mkdir -p $(DNNL_DIR)/build && cd $(DNNL_DIR)/build && cmake -DCMAKE_CXX_ENCLAVE_FLAGS="$(CXX_ENCLAVE_FLAGS)" -DCMAKE_C_ENCLAVE_FLAGS="$(C_ENCLAVE_FLAGS)" $(DNNL_CONFIG) .. && make
diff --git a/external/dnnl/sgx_dnnl.patch b/external/dnnl/sgx_dnnl.patch
deleted file mode 100644
index f61372b3..00000000
--- a/external/dnnl/sgx_dnnl.patch
+++ /dev/null
@@ -1,615 +0,0 @@
-From 87db3f93811d743fb820224e5a74c41ef54580a8 Mon Sep 17 00:00:00 2001
-From: zhoul1 <liang.a.zhou@intel.com>
-Date: Thu, 7 Nov 2019 02:20:39 +0800
-Subject: [PATCH] SGX mkl-dnn.
-
----
- cmake/options.cmake                           | 11 ++--
- cmake/platform.cmake                          |  8 ++-
- src/CMakeLists.txt                            |  4 ++
- src/common/engine.hpp                         |  2 +
- src/common/primitive.cpp                      |  4 ++
- src/common/utils.cpp                          | 15 ++++++
- src/common/utils.hpp                          |  2 +
- src/common/verbose.cpp                        |  8 +++
- src/cpu/jit_uni_reorder_utils.cpp             |  2 +
- src/cpu/jit_utils/jit_utils.cpp               |  8 +++
- src/cpu/jit_utils/jitprofiling/jitprofiling.c |  5 ++
- src/cpu/xbyak/xbyak.h                         | 54 +++++++++++++++++++
- src/cpu/xbyak/xbyak_util.h                    | 28 ++++++++++
- 13 files changed, 147 insertions(+), 4 deletions(-)
-
-diff --git a/cmake/options.cmake b/cmake/options.cmake
-index 0f77e936a..ead9f472a 100644
---- a/cmake/options.cmake
-+++ b/cmake/options.cmake
-@@ -46,13 +46,18 @@ option(DNNL_ENABLE_PRIMITIVE_CACHE "enables primitive cache.
- # Building properties and scope
- # =============================
- 
--set(DNNL_LIBRARY_TYPE "SHARED" CACHE STRING
-+set(DNNL_LIBRARY_TYPE "STATIC" CACHE STRING
-     "specifies whether DNNL library should be SHARED or STATIC")
--option(DNNL_BUILD_EXAMPLES "builds examples"  ON)
--option(DNNL_BUILD_TESTS "builds tests" ON)
-+option(DNNL_BUILD_EXAMPLES "builds examples"  OFF)
-+option(DNNL_BUILD_TESTS "builds tests" OFF)
- option(DNNL_BUILD_FOR_CI "specifies whether DNNL library should be built for CI" OFF)
- option(DNNL_WERROR "treat warnings as errors" OFF)
- 
-+#set( CMAKE_VERBOSE_MAKEFILE on )  #echo the build command info
-+# ==enable DEBUG==
-+#set( CMAKE_BUILD_TYPE Debug )
-+#SET( CMAKE_CXX_FLAGS_DEBUG "$ENV{CXXFLAGS} -O0 -Wall -g -ggdb")
-+
- set(DNNL_INSTALL_MODE "DEFAULT" CACHE STRING
-     "specifies installation mode; supports DEFAULT or BUNDLE.
- 
-diff --git a/cmake/platform.cmake b/cmake/platform.cmake
-index a12090e5e..58cf86544 100644
---- a/cmake/platform.cmake
-+++ b/cmake/platform.cmake
-@@ -30,6 +30,11 @@ add_definitions(-DDNNL_DLL -DDNNL_DLL_EXPORTS)
- # C++ standard (see C99 standard 7.18.2 and 7.18.4)
- add_definitions(-D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS)
- 
-+#SGX
-+add_definitions(-DMKLDNN_SGX -DDISABLE_VERBOSE -DSGX_XBYAK)
-+set(CMAKE_CXX_ENCLAVE_FLAGS)
-+set(CMAKE_C_ENCLAVE_FLAGS)
-+
- set(CMAKE_CCXX_FLAGS)
- set(CMAKE_CCXX_NOWARN_FLAGS)
- set(DEF_ARCH_OPT_FLAGS)
-@@ -83,7 +88,8 @@ elseif(UNIX OR MINGW)
-     append(CMAKE_CCXX_FLAGS "-Wall -Wno-unknown-pragmas")
-     append_if(DNNL_WERROR CMAKE_CCXX_FLAGS "-Werror")
-     append(CMAKE_CCXX_FLAGS "-fvisibility=internal")
--    append(CMAKE_CXX_FLAGS "-fvisibility-inlines-hidden")
-+    append(CMAKE_CXX_FLAGS "-fvisibility-inlines-hidden ${CMAKE_CXX_ENCLAVE_FLAGS}")
-+    append(CMAKE_C_FLAGS "${CMAKE_C_ENCLAVE_FLAGS}")
-     # compiler specific settings
-     if(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
-         set(DEF_ARCH_OPT_FLAGS "-msse4.1")
-diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
-index 4c774a11b..0bc235295 100644
---- a/src/CMakeLists.txt
-+++ b/src/CMakeLists.txt
-@@ -22,6 +22,10 @@ file(GLOB_RECURSE HEADERS
- include_directories(
-     ${CMAKE_CURRENT_SOURCE_DIR}
-     ${CMAKE_CURRENT_SOURCE_DIR}/common
-+    ${CMAKE_CURRENT_SOURCE_DIR}/../../../../common/inc/internal
-+    ${CMAKE_CURRENT_SOURCE_DIR}/../../../../common/inc/tlibc
-+    ${CMAKE_CURRENT_SOURCE_DIR}/../../../../common/inc
-+    ${CMAKE_CURRENT_SOURCE_DIR}/../../../../sdk/tlibcxx/include
-     )
- 
- # propagate SRC specific flags
-diff --git a/src/common/engine.hpp b/src/common/engine.hpp
-index 056e3bfb4..90b5d32b1 100644
---- a/src/common/engine.hpp
-+++ b/src/common/engine.hpp
-@@ -126,6 +126,7 @@ struct dnnl_engine : public dnnl::impl::c_compatible {
- 
-         auto print_verbose = [](int level, bool is_cache_hit,
-                                      dnnl::impl::primitive_t *p, double time) {
-+#ifndef MKLDNN_SGX
-             if (level >= 2) {
- #ifdef DNNL_ENABLE_PRIMITIVE_CACHE
-                 const char *str = is_cache_hit
-@@ -137,6 +138,7 @@ struct dnnl_engine : public dnnl::impl::c_compatible {
-                 printf("%s,%s,%g\n", str, p->pd()->info(), time);
-                 fflush(0);
-             }
-+#endif
-         };
- 
-         double ms = dnnl::impl::get_msec();
-diff --git a/src/common/primitive.cpp b/src/common/primitive.cpp
-index 63529088b..876606b53 100644
---- a/src/common/primitive.cpp
-+++ b/src/common/primitive.cpp
-@@ -77,7 +77,9 @@ status_t dnnl_primitive_execute(const primitive_t *primitive, stream_t *stream,
-         // level is at least gpu_exec_time_level
-         if (stream->engine()->kind() == engine_kind::gpu
-                 && dnnl_verbose()->level < gpu_exec_time_level) {
-+            #ifndef MKLDNN_SGX
-             printf("dnnl_verbose,exec,%s\n", primitive->pd()->info());
-+            #endif
-         } else {
-             // GPU engines require synchronization to measure actual time
-             // For CPU engines wait() is no-op
-@@ -85,6 +87,7 @@ status_t dnnl_primitive_execute(const primitive_t *primitive, stream_t *stream,
-             ms = get_msec() - ms;
-         }
- 
-+        #ifndef MKLDNN_SGX
-         engine_kind_t engine_kind = stream->engine()->kind();
-         if (engine_kind == engine_kind::cpu
-                 || (engine_kind == engine_kind::gpu
-@@ -92,6 +95,7 @@ status_t dnnl_primitive_execute(const primitive_t *primitive, stream_t *stream,
-             printf("dnnl_verbose,exec,%s,%g\n", primitive->pd()->info(), ms);
-             fflush(0);
-         }
-+       #endif
-     } else {
-         status = primitive->execute(ctx);
-     }
-diff --git a/src/common/utils.cpp b/src/common/utils.cpp
-index 06860e0ff..15ca311ac 100644
---- a/src/common/utils.cpp
-+++ b/src/common/utils.cpp
-@@ -30,6 +30,7 @@ namespace dnnl {
- namespace impl {
- 
- int getenv(const char *name, char *buffer, int buffer_size) {
-+#ifndef MKLDNN_SGX
-     if (name == NULL || buffer_size < 0 || (buffer == NULL && buffer_size > 0))
-         return INT_MIN;
- 
-@@ -61,17 +62,25 @@ int getenv(const char *name, char *buffer, int buffer_size) {
- 
-     if (buffer != NULL) buffer[term_zero_idx] = '\0';
-     return result;
-+#else
-+    return 0;
-+#endif
- }
- 
- int getenv_int(const char *name, int default_value) {
-+#ifndef MKLDNN_SGX
-     int value = default_value;
-     // # of digits in the longest 32-bit signed int + sign + terminating null
-     const int len = 12;
-     char value_str[len];
-     if (getenv(name, value_str, len) > 0) value = atoi(value_str);
-     return value;
-+#else
-+    return 0;
-+#endif
- }
- 
-+#ifndef MKLDNN_SGX
- FILE *fopen(const char *filename, const char *mode) {
- #ifdef _WIN32
-     FILE *fp = NULL;
-@@ -80,6 +89,7 @@ FILE *fopen(const char *filename, const char *mode) {
-     return ::fopen(filename, mode);
- #endif
- }
-+#endif
- 
- void *malloc(size_t size, int alignment) {
-     void *ptr;
-@@ -88,7 +98,12 @@ void *malloc(size_t size, int alignment) {
-     ptr = _aligned_malloc(size, alignment);
-     int rc = ptr ? 0 : -1;
- #else
-+    #ifndef MKLDNN_SGX
-     int rc = ::posix_memalign(&ptr, alignment, size);
-+    #else
-+    ptr = ::memalign(alignment, size);
-+    int rc = ((ptr)? 0 : -1);
-+    #endif
- #endif
- 
-     return (rc == 0) ? ptr : 0;
-diff --git a/src/common/utils.hpp b/src/common/utils.hpp
-index d9e547144..a2702c474 100644
---- a/src/common/utils.hpp
-+++ b/src/common/utils.hpp
-@@ -451,7 +451,9 @@ int getenv(const char *name, char *buffer, int buffer_size);
- // Reads an integer from the environment
- int getenv_int(const char *name, int default_value = 0);
- bool jit_dump_enabled();
-+#ifndef MKLDNN_SGX
- FILE *fopen(const char *filename, const char *mode);
-+#endif
- 
- constexpr int msan_enabled = MSAN_ENABLED;
- inline void msan_unpoison(void *ptr, size_t size) {
-diff --git a/src/common/verbose.cpp b/src/common/verbose.cpp
-index 02582bab4..c236f3e6c 100644
---- a/src/common/verbose.cpp
-+++ b/src/common/verbose.cpp
-@@ -15,9 +15,11 @@
- *******************************************************************************/
- 
- #include <stdlib.h>
-+#ifndef MKLDNN_SGX
- #ifndef _WIN32
- #include <sys/time.h>
- #endif
-+#endif
- 
- #include "dnnl.h"
- #include "dnnl_version.h"
-@@ -64,7 +66,9 @@ namespace impl {
- 
- static verbose_t verbose;
- static bool initialized;
-+#ifndef MKLDNN_SGX
- static bool version_printed = false;
-+#endif
- 
- const verbose_t *dnnl_verbose() {
- #if !defined(DISABLE_VERBOSE)
-@@ -96,9 +100,13 @@ double get_msec() {
-     QueryPerformanceCounter(&now);
-     return 1e+3 * now.QuadPart / frequency.QuadPart;
- #else
-+    #ifndef MKLDNN_SGX
-     struct timeval time;
-     gettimeofday(&time, NULL);
-     return 1e+3 * time.tv_sec + 1e-3 * time.tv_usec;
-+    #else
-+    return 0.0;
-+    #endif
- #endif
- }
- 
-diff --git a/src/cpu/jit_uni_reorder_utils.cpp b/src/cpu/jit_uni_reorder_utils.cpp
-index 05b1376b9..6d481eedc 100644
---- a/src/cpu/jit_uni_reorder_utils.cpp
-+++ b/src/cpu/jit_uni_reorder_utils.cpp
-@@ -284,12 +284,14 @@ void prb_node_move(prb_t &p, int d0, int d1) {
- }
- 
- void prb_dump(const prb_t &p) {
-+#ifndef MKLDNN_SGX
-     printf("@@@ type:%s:%s ndims:%d ", dnnl_dt2str(p.itype),
-             dnnl_dt2str(p.otype), p.ndims);
-     for (int d = 0; d < p.ndims; ++d)
-         printf("[%zu:%td:%td:%td]", p.nodes[d].n, p.nodes[d].is, p.nodes[d].os,
-                 p.nodes[d].ss);
-     printf(" off:%zu:%zu\n", p.ioff, p.ooff);
-+#endif
- }
- 
- } // namespace tr
-diff --git a/src/cpu/jit_utils/jit_utils.cpp b/src/cpu/jit_utils/jit_utils.cpp
-index 4fa42a0e3..903fed7ca 100644
---- a/src/cpu/jit_utils/jit_utils.cpp
-+++ b/src/cpu/jit_utils/jit_utils.cpp
-@@ -18,13 +18,21 @@
- 
- #include "utils.hpp"
- 
-+#ifndef MKLDNN_SGX
- #ifndef DNNL_ENABLE_JIT_PROFILING
- #define DNNL_ENABLE_JIT_PROFILING 1
- #endif
-+#else
-+#undef DNNL_ENABLE_JIT_PROFILING
-+#endif
- 
-+#ifndef MKLDNN_SGX
- #ifndef DNNL_ENABLE_JIT_DUMP
- #define DNNL_ENABLE_JIT_DUMP 1
- #endif
-+#else
-+#undef DNNL_ENABLE_JIT_DUMP
-+#endif
- 
- #if DNNL_ENABLE_JIT_PROFILING
- #include "jitprofiling/jitprofiling.h"
-diff --git a/src/cpu/jit_utils/jitprofiling/jitprofiling.c b/src/cpu/jit_utils/jitprofiling/jitprofiling.c
-index fd99cb5f3..433d58370 100644
---- a/src/cpu/jit_utils/jitprofiling/jitprofiling.c
-+++ b/src/cpu/jit_utils/jitprofiling/jitprofiling.c
-@@ -35,6 +35,8 @@
-   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- </copyright> */
- 
-+#ifndef MKLDNN_SGX
-+
- #include "ittnotify_config.h"
- 
- #if ITT_PLATFORM==ITT_PLATFORM_WIN
-@@ -291,3 +293,6 @@ ITT_EXTERN_C unsigned int JITAPI iJIT_GetNewMethodID()
- 
-     return methodID++;
- }
-+
-+#endif  //#ifndef MKLDNN_SGX
-+
-diff --git a/src/cpu/xbyak/xbyak.h b/src/cpu/xbyak/xbyak.h
-index 45718b59c..4b8983a75 100644
---- a/src/cpu/xbyak/xbyak.h
-+++ b/src/cpu/xbyak/xbyak.h
-@@ -69,6 +69,10 @@
- #include <iostream>
- #endif
- 
-+#ifdef SGX_XBYAK
-+#include "sgx_rsrv_mem_mngr.h"
-+#endif
-+
- // #define XBYAK_DISABLE_AVX512
- 
- //#define XBYAK_USE_MMAP_ALLOCATOR
-@@ -122,7 +126,9 @@
- 	#include <malloc.h>
- #elif defined(__GNUC__)
- 	#include <unistd.h>
-+	#ifndef SGX_XBYAK       
- 	#include <sys/mman.h>
-+	#endif
- 	#include <stdlib.h>
- #endif
- #if !defined(_MSC_VER) || (_MSC_VER >= 1600)
-@@ -240,10 +246,12 @@ class Error : public std::exception {
- public:
- 	explicit Error(int err) : err_(err)
- 	{
-+		#ifndef SGX_XBYAK
- 		if (err_ < 0 || err_ > ERR_INTERNAL) {
- 			fprintf(stderr, "bad err=%d in Xbyak::Error\n", err_);
- 			exit(1);
- 		}
-+		#endif
- 	}
- 	operator int() const { return err_; }
- 	const char *what() const throw()
-@@ -313,9 +321,13 @@ inline void *AlignedMalloc(size_t size, size_t alignment)
- #elif defined(_WIN32)
- 	return _aligned_malloc(size, alignment);
- #else
-+	#ifndef SGX_XBYAK
- 	void *p;
- 	int ret = posix_memalign(&p, alignment, size);
- 	return (ret == 0) ? p : 0;
-+	#else
-+	return NULL;
-+	#endif
- #endif
- }
- 
-@@ -378,6 +390,7 @@ public:
- 	{
- 		const size_t alignedSizeM1 = inner::ALIGN_PAGE_SIZE - 1;
- 		size = (size + alignedSizeM1) & ~alignedSizeM1;
-+#ifndef SGX_XBYAK
- #ifdef MAP_ANONYMOUS
- 		const int mode = MAP_PRIVATE | MAP_ANONYMOUS;
- #elif defined(MAP_ANON)
-@@ -390,13 +403,27 @@ public:
- 		assert(p);
- 		sizeList_[(uintptr_t)p] = size;
- 		return (uint8*)p;
-+#else
-+		void *p = sgx_alloc_rsrv_mem(size);
-+		if (p == NULL)
-+			abort();
-+		sizeList_[(uintptr_t)p] = size;
-+		return (uint8*)p;
-+#endif
- 	}
- 	void free(uint8 *p)
- 	{
- 		if (p == 0) return;
- 		SizeList::iterator i = sizeList_.find((uintptr_t)p);
-+#ifndef SGX_XBYAK
- 		if (i == sizeList_.end()) throw Error(ERR_BAD_PARAMETER);
- 		if (munmap((void*)i->first, i->second) < 0) throw Error(ERR_MUNMAP);
-+#else
-+		if (i == sizeList_.end())
-+			abort();
-+		if(sgx_free_rsrv_mem((void*)i->first, i->second) !=  0)
-+			abort();
-+#endif
- 		sizeList_.erase(i);
- 	}
- };
-@@ -956,8 +983,14 @@ public:
- 	explicit CodeArray(size_t maxSize, void *userPtr = 0, Allocator *allocator = 0)
- 		: type_(userPtr == AutoGrow ? AUTO_GROW : (userPtr == 0 || userPtr == DontSetProtectRWE) ? ALLOC_BUF : USER_BUF)
- 		, alloc_(allocator ? allocator : (Allocator*)&defaultAllocator_)
-+		#ifndef SGX_XBYAK
- 		, maxSize_(maxSize)
- 		, top_(type_ == USER_BUF ? reinterpret_cast<uint8*>(userPtr) : alloc_->alloc((std::max<size_t>)(maxSize, 1)))
-+		#else
-+		//Inside SGX, the allocated memory size must be page aligned.
-+		, maxSize_((maxSize +  (inner::ALIGN_PAGE_SIZE - 1)) & ~(inner::ALIGN_PAGE_SIZE - 1))
-+		, top_(type_ == USER_BUF ? reinterpret_cast<uint8*>(userPtr) : alloc_->alloc((std::max<size_t>)(((maxSize +  (inner::ALIGN_PAGE_SIZE - 1)) & ~(inner::ALIGN_PAGE_SIZE - 1)), 1)))
-+		#endif
- 		, size_(0)
- 		, isCalledCalcJmpAddress_(false)
- 	{
-@@ -1026,6 +1059,7 @@ public:
- 	}
- 	void dump() const
- 	{
-+		#ifndef SGX_XBYAK
- 		const uint8 *p = getCode();
- 		size_t bufSize = getSize();
- 		size_t remain = bufSize;
-@@ -1045,6 +1079,7 @@ public:
- 				break;
- 			}
- 		}
-+		#endif
- 	}
- 	/*
- 		@param offset [in] offset from top
-@@ -1075,6 +1110,7 @@ public:
- 	*/
- 	static inline bool protect(const void *addr, size_t size, int protectMode)
- 	{
-+#ifndef SGX_XBYAK
- #if defined(_WIN32)
- 		const DWORD c_rw = PAGE_READWRITE;
- 		const DWORD c_rwe = PAGE_EXECUTE_READWRITE;
-@@ -1106,6 +1142,20 @@ public:
- 		return mprotect(reinterpret_cast<void*>(roundAddr), size + (iaddr - roundAddr), mode) == 0;
- #else
- 		return true;
-+#endif
-+#else
-+	const int c_rw = SGX_PROT_READ | SGX_PROT_WRITE;
-+	const int c_rwe = SGX_PROT_READ | SGX_PROT_WRITE | SGX_PROT_EXEC;
-+	const int c_re = SGX_PROT_READ | SGX_PROT_EXEC;
-+	int mode;
-+	switch (protectMode) {
-+	case PROTECT_RW: mode = c_rw; break;
-+	case PROTECT_RWE: mode = c_rwe; break;
-+	case PROTECT_RE: mode = c_re; break;
-+	default:
-+		return false;
-+	}
-+	return sgx_tprotect_rsrv_mem(const_cast<void*>(addr), size, mode) == 0;
- #endif
- 	}
- 	/**
-@@ -1339,9 +1389,11 @@ class LabelManager {
- 	bool hasUndefinedLabel_inner(const T& list) const
- 	{
- #ifndef NDEBUG
-+		#ifndef SGX_XBYAK
- 		for (typename T::const_iterator i = list.begin(); i != list.end(); ++i) {
- 			std::cerr << "undefined label:" << i->first << std::endl;
- 		}
-+		#endif
- #endif
- 		return !list.empty();
- 	}
-@@ -2638,7 +2690,9 @@ public:
- 	{
- 		if (x == 1) return;
- 		if (x < 1 || (x & (x - 1))) throw Error(ERR_BAD_ALIGN);
-+		#ifndef SGX_XBYAK
- 		if (isAutoGrow() && x > inner::ALIGN_PAGE_SIZE) fprintf(stderr, "warning:autoGrow mode does not support %d align\n", (int)x);
-+		#endif
- 		size_t remain = size_t(getCurr()) % x;
- 		if (remain) {
- 			nop(x - remain, useMultiByteNop);
-diff --git a/src/cpu/xbyak/xbyak_util.h b/src/cpu/xbyak/xbyak_util.h
-index 68a1e24ff..797c85c52 100644
---- a/src/cpu/xbyak/xbyak_util.h
-+++ b/src/cpu/xbyak/xbyak_util.h
-@@ -86,7 +86,11 @@
-     	#define __GNUC_PREREQ(major, minor) ((((__GNUC__) << 16) + (__GNUC_MINOR__)) >= (((major) << 16) + (minor)))
- 	#endif
- 	#if __GNUC_PREREQ(4, 3) && !defined(__APPLE__)
-+		#ifndef SGX_XBYAK
- 		#include <cpuid.h>
-+		#else
-+		#include <sgx_cpuid.h>
-+		#endif
- 	#else
- 		#if defined(__APPLE__) && defined(XBYAK32) // avoid err : can't find a register in class `BREG' while reloading `asm'
- 			#define __cpuid(eaxIn, a, b, c, d) __asm__ __volatile__("pushl %%ebx\ncpuid\nmovl %%ebp, %%esi\npopl %%ebx" : "=a"(a), "=S"(b), "=c"(c), "=d"(d) : "0"(eaxIn))
-@@ -273,11 +277,15 @@ public:
- 	static inline void getCpuid(unsigned int eaxIn, unsigned int data[4])
- 	{
- #ifdef XBYAK_INTEL_CPU_SPECIFIC
-+	#ifndef SGX_XBYAK
- 	#ifdef _MSC_VER
- 		__cpuid(reinterpret_cast<int*>(data), eaxIn);
- 	#else
- 		__cpuid(eaxIn, data[0], data[1], data[2], data[3]);
- 	#endif
-+	#else
-+		sgx_cpuid((int*)data, eaxIn);
-+	#endif
- #else
- 		(void)eaxIn;
- 		(void)data;
-@@ -286,11 +294,15 @@ public:
- 	static inline void getCpuidEx(unsigned int eaxIn, unsigned int ecxIn, unsigned int data[4])
- 	{
- #ifdef XBYAK_INTEL_CPU_SPECIFIC
-+	#ifndef SGX_XBYAK
- 	#ifdef _MSC_VER
- 		__cpuidex(reinterpret_cast<int*>(data), eaxIn, ecxIn);
- 	#else
- 		__cpuid_count(eaxIn, ecxIn, data[0], data[1], data[2], data[3]);
- 	#endif
-+	#else
-+		sgx_cpuidex((int*)data, eaxIn, ecxIn);
-+	#endif
- #else
- 		(void)eaxIn;
- 		(void)ecxIn;
-@@ -491,9 +503,11 @@ public:
- 	}
- 	void putFamily() const
- 	{
-+		#ifndef SGX_XBYAK
- 		printf("family=%d, model=%X, stepping=%d, extFamily=%d, extModel=%X\n",
- 			family, model, stepping, extFamily, extModel);
- 		printf("display:family=%X, model=%X\n", displayFamily, displayModel);
-+		#endif
- 	}
- 	bool has(Type type) const
- 	{
-@@ -585,7 +599,9 @@ public:
- 	Pack& append(const Xbyak::Reg64& t)
- 	{
- 		if (n_ == maxTblNum) {
-+			#ifndef SGX_XBYAK
- 			fprintf(stderr, "ERR Pack::can't append\n");
-+			#endif
- 			throw Error(ERR_BAD_PARAMETER);
- 		}
- 		tbl_[n_++] = &t;
-@@ -594,7 +610,9 @@ public:
- 	void init(const Xbyak::Reg64 *tbl, size_t n)
- 	{
- 		if (n > maxTblNum) {
-+			#ifndef SGX_XBYAK
- 			fprintf(stderr, "ERR Pack::init bad n=%d\n", (int)n);
-+			#endif
- 			throw Error(ERR_BAD_PARAMETER);
- 		}
- 		n_ = n;
-@@ -605,7 +623,9 @@ public:
- 	const Xbyak::Reg64& operator[](size_t n) const
- 	{
- 		if (n >= n_) {
-+			#ifndef SGX_XBYAK
- 			fprintf(stderr, "ERR Pack bad n=%d(%d)\n", (int)n, (int)n_);
-+			#endif
- 			throw Error(ERR_BAD_PARAMETER);
- 		}
- 		return *tbl_[n];
-@@ -618,7 +638,9 @@ public:
- 	{
- 		if (num == size_t(-1)) num = n_ - pos;
- 		if (pos + num > n_) {
-+			#ifndef SGX_XBYAK
- 			fprintf(stderr, "ERR Pack::sub bad pos=%d, num=%d\n", (int)pos, (int)num);
-+			#endif
- 			throw Error(ERR_BAD_PARAMETER);
- 		}
- 		Pack pack;
-@@ -630,10 +652,12 @@ public:
- 	}
- 	void put() const
- 	{
-+		#ifndef SGX_XBYAK
- 		for (size_t i = 0; i < n_; i++) {
- 			printf("%s ", tbl_[i]->toString());
- 		}
- 		printf("\n");
-+		#endif
- 	}
- };
- 
-@@ -741,8 +765,12 @@ public:
- 		try {
- 			close();
- 		} catch (std::exception& e) {
-+			#ifndef SGX_XBYAK
- 			printf("ERR:StackFrame %s\n", e.what());
- 			exit(1);
-+			#else
-+			abort();
-+			#endif
- 		}
- 	}
- private:
--- 
-2.17.1
-
-- 
2.25.1


